/* auto-generated by NAPI-RS */

/**
 * Options for the lang command.
 */
export interface LangOptions {
  /** List of paths to scan (default: ["."]) */
  paths?: string[];
  /** Show only top N languages (0 = all, default: 0) */
  top?: number;
  /** Include file counts (default: false) */
  files?: boolean;
  /** How to handle embedded languages ("collapse" or "separate") */
  children?: "collapse" | "separate";
  /** Redaction mode ("none", "paths", "all") */
  redact?: "none" | "paths" | "all";
  /** List of glob patterns to exclude */
  excluded?: string[];
  /** Include hidden files (default: false) */
  hidden?: boolean;
}

/**
 * Options for the module command.
 */
export interface ModuleOptions {
  /** List of paths to scan (default: ["."]) */
  paths?: string[];
  /** Show only top N modules (0 = all, default: 0) */
  top?: number;
  /** Top-level directories as module roots */
  module_roots?: string[];
  /** Path segments to include for module roots (default: 2) */
  module_depth?: number;
  /** How to handle embedded languages ("collapse" or "separate") */
  children?: "collapse" | "separate";
  /** Redaction mode ("none", "paths", "all") */
  redact?: "none" | "paths" | "all";
  /** List of glob patterns to exclude */
  excluded?: string[];
  /** Include hidden files (default: false) */
  hidden?: boolean;
}

/**
 * Options for the export command.
 */
export interface ExportOptions {
  /** List of paths to scan (default: ["."]) */
  paths?: string[];
  /** Output format ("jsonl", "json", "csv", "cyclonedx") */
  format?: "jsonl" | "json" | "csv" | "cyclonedx";
  /** Minimum lines of code to include (default: 0) */
  min_code?: number;
  /** Maximum rows to return (0 = unlimited) */
  max_rows?: number;
  /** How to handle embedded languages ("collapse" or "separate") */
  children?: "collapse" | "separate";
  /** Redaction mode ("none", "paths", "all") */
  redact?: "none" | "paths" | "all";
  /** List of glob patterns to exclude */
  excluded?: string[];
  /** Include hidden files (default: false) */
  hidden?: boolean;
}

/**
 * Options for the analyze command.
 */
export interface AnalyzeOptions {
  /** List of paths to scan (default: ["."]) */
  paths?: string[];
  /** Analysis preset ("receipt", "health", "risk", "supply", "architecture", "topics", "security", "identity", "git", "deep", "fun") */
  preset?: "receipt" | "health" | "risk" | "supply" | "architecture" | "topics" | "security" | "identity" | "git" | "deep" | "fun";
  /** Context window size in tokens */
  window?: number;
  /** Force enable/disable git metrics */
  git?: boolean;
  /** How to handle embedded languages ("collapse" or "separate") */
  children?: "collapse" | "separate";
  /** Redaction mode ("none", "paths", "all") */
  redact?: "none" | "paths" | "all";
  /** List of glob patterns to exclude */
  excluded?: string[];
  /** Include hidden files (default: false) */
  hidden?: boolean;
}

/**
 * A row in the language receipt.
 */
export interface LangRow {
  /** Language name */
  lang: string;
  /** Number of files (if requested) */
  files?: number;
  /** Lines of code */
  code: number;
  /** Lines of comments */
  comments: number;
  /** Blank lines */
  blanks: number;
  /** Total lines */
  total: number;
}

/**
 * Language receipt returned by the lang command.
 */
export interface LangReceipt {
  /** Schema version */
  schema_version: number;
  /** Receipt generation timestamp */
  generated_at: string;
  /** Rows of language data */
  rows: LangRow[];
  /** Total counts across all languages */
  totals: {
    files?: number;
    code: number;
    comments: number;
    blanks: number;
    total: number;
  };
}

/**
 * A row in the module receipt.
 */
export interface ModuleRow {
  /** Module path/key */
  module: string;
  /** Number of files */
  files: number;
  /** Lines of code */
  code: number;
  /** Lines of comments */
  comments: number;
  /** Blank lines */
  blanks: number;
  /** Total lines */
  total: number;
}

/**
 * Module receipt returned by the module command.
 */
export interface ModuleReceipt {
  /** Schema version */
  schema_version: number;
  /** Receipt generation timestamp */
  generated_at: string;
  /** Rows of module data */
  rows: ModuleRow[];
  /** Total counts across all modules */
  totals: {
    files: number;
    code: number;
    comments: number;
    blanks: number;
    total: number;
  };
}

/**
 * A row in the export receipt.
 */
export interface ExportRow {
  /** File path */
  path: string;
  /** Language name */
  lang: string;
  /** Lines of code */
  code: number;
  /** Lines of comments */
  comments: number;
  /** Blank lines */
  blanks: number;
  /** Total lines */
  total: number;
}

/**
 * Export receipt returned by the export command.
 */
export interface ExportReceipt {
  /** Schema version */
  schema_version: number;
  /** Receipt generation timestamp */
  generated_at: string;
  /** Rows of file data */
  rows: ExportRow[];
  /** Total counts across all files */
  totals: {
    files: number;
    code: number;
    comments: number;
    blanks: number;
    total: number;
  };
}

/**
 * Derived metrics from analysis.
 */
export interface DerivedMetrics {
  /** Documentation density metrics */
  doc_density?: {
    total: {
      ratio: number;
      grade: string;
    };
    by_lang?: Record<string, { ratio: number; grade: string }>;
  };
  /** Code distribution metrics */
  distribution?: {
    gini: number;
    top_files: Array<{ path: string; code: number; percent: number }>;
  };
  /** COCOMO estimation */
  cocomo?: {
    person_months: number;
    schedule_months: number;
    team_size: number;
    cost_usd: number;
  };
  /** TODO density metrics */
  todo_density?: {
    total_todos: number;
    density_per_kloc: number;
  };
  /** Git-based metrics (if enabled) */
  git_hotspots?: Array<{ path: string; score: number; commits: number; authors: number }>;
  /** Asset inventory */
  assets?: {
    images: string[];
    fonts: string[];
    data: string[];
    other: string[];
  };
  /** Import graph */
  import_graph?: {
    nodes: string[];
    edges: Array<{ from: string; to: string }>;
  };
}

/**
 * Analysis receipt returned by the analyze command.
 */
export interface AnalyzeReceipt {
  /** Schema version */
  schema_version: number;
  /** Receipt generation timestamp */
  generated_at: string;
  /** Analysis preset used */
  preset: string;
  /** Base inventory data */
  inventory: {
    rows: LangRow[];
    totals: {
      files?: number;
      code: number;
      comments: number;
      blanks: number;
      total: number;
    };
  };
  /** Derived metrics */
  derived?: DerivedMetrics;
}

/**
 * Diff receipt returned by the diff command.
 */
export interface DiffReceipt {
  /** Schema version */
  schema_version: number;
  /** Receipt generation timestamp */
  generated_at: string;
  /** From path/receipt */
  from: string;
  /** To path/receipt */
  to: string;
  /** Per-language deltas */
  rows: Array<{
    lang: string;
    delta_code: number;
    delta_comments: number;
    delta_blanks: number;
    delta_total: number;
  }>;
  /** Total deltas */
  totals: {
    delta_code: number;
    delta_comments: number;
    delta_blanks: number;
    delta_total: number;
  };
}

/**
 * Get the tokmd version string.
 *
 * @returns The version of tokmd (e.g., "1.3.1")
 *
 * @example
 * ```javascript
 * import { version } from '@tokmd/core';
 * console.log(version()); // "1.3.1"
 * ```
 */
export function version(): string;

/**
 * Get the JSON schema version.
 *
 * @returns The current schema version for receipts
 *
 * @example
 * ```javascript
 * import { schemaVersion } from '@tokmd/core';
 * console.log(schemaVersion()); // 2
 * ```
 */
export function schemaVersion(): number;

/**
 * Run a tokmd operation with JSON arguments, returning a JSON string.
 *
 * This is the low-level API that accepts and returns JSON strings.
 * For most use cases, prefer the convenience functions.
 *
 * @param mode - The operation mode ("lang", "module", "export", "analyze", "diff", "version")
 * @param argsJson - JSON string containing the arguments
 * @returns Promise resolving to JSON string containing the result or error
 *
 * @example
 * ```javascript
 * import { runJson } from '@tokmd/core';
 * const result = await runJson("lang", JSON.stringify({ paths: ["."] }));
 * const data = JSON.parse(result);
 * ```
 */
export function runJson(mode: string, argsJson: string): Promise<string>;

/**
 * Run a tokmd operation and return the result as a JavaScript object.
 *
 * @param mode - The operation mode ("lang", "module", "export", "analyze", "diff", "version")
 * @param args - Object containing the arguments
 * @returns Promise resolving to the result object
 * @throws Error if the operation fails
 *
 * @example
 * ```javascript
 * import { run } from '@tokmd/core';
 * const result = await run("lang", { paths: ["."], top: 10 });
 * console.log(result.rows[0].lang);
 * ```
 */
export function run(mode: string, args: Record<string, unknown>): Promise<Record<string, unknown>>;

/**
 * Scan paths and return a language summary.
 *
 * @param options - Scan options
 * @returns Promise resolving to language receipt
 *
 * @example
 * ```javascript
 * import { lang } from '@tokmd/core';
 * const result = await lang({ paths: ["src"], top: 5 });
 * for (const row of result.rows) {
 *   console.log(`${row.lang}: ${row.code} lines`);
 * }
 * ```
 */
export function lang(options?: LangOptions): Promise<LangReceipt>;

/**
 * Scan paths and return a module summary.
 *
 * @param options - Scan options
 * @returns Promise resolving to module receipt
 *
 * @example
 * ```javascript
 * import { module } from '@tokmd/core';
 * const result = await module({ paths: ["."], module_roots: ["crates"] });
 * ```
 */
declare function module(options?: ModuleOptions): Promise<ModuleReceipt>;
export { module };

/**
 * Scan paths and return file-level export data.
 *
 * @param options - Export options
 * @returns Promise resolving to export receipt
 *
 * @example
 * ```javascript
 * import { export as exportData } from '@tokmd/core';
 * const result = await exportData({ paths: ["src"], min_code: 10 });
 * console.log(`Found ${result.rows.length} files`);
 * ```
 */
declare function exportFn(options?: ExportOptions): Promise<ExportReceipt>;
export { exportFn as export };

/**
 * Run analysis on paths and return derived metrics.
 *
 * @param options - Analysis options
 * @returns Promise resolving to analysis receipt
 *
 * @example
 * ```javascript
 * import { analyze } from '@tokmd/core';
 * const result = await analyze({ paths: ["."], preset: "health" });
 * if (result.derived) {
 *   console.log(`Doc density: ${result.derived.doc_density.total.ratio}`);
 * }
 * ```
 */
export function analyze(options?: AnalyzeOptions): Promise<AnalyzeReceipt>;

/**
 * Compare two receipts or paths and return a diff.
 *
 * @param fromPath - Base receipt file or path to scan
 * @param toPath - Target receipt file or path to scan
 * @returns Promise resolving to diff receipt
 *
 * @example
 * ```javascript
 * import { diff } from '@tokmd/core';
 * const result = await diff("old_receipt.json", "new_receipt.json");
 * console.log(`Total delta: ${result.totals.delta_code} lines`);
 * ```
 */
export function diff(fromPath: string, toPath: string): Promise<DiffReceipt>;
