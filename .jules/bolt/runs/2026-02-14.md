# Bolt Run: 2026-02-14

## Context
- Read CI config and documentation.
- Initialized `.jules` structure.

## Lane Selection
- [ ] Lane A: Friction
- [x] Lane B: Scout

**Target:** `tokmd-model` module key allocation in `collect_file_rows`.
Repeated allocation of duplicate module strings for every file.

## Options
### Option A: Cache module keys (Recommended)
Introduce a `HashMap<String, String>` or similar cache to map normalized paths (or partial paths) to module keys.
Or, even better, map the module string itself.
Wait, `module_key_from_normalized` returns a new String.
If we can memoize the result based on the input path's relevant prefix?
Or simply: `collect_file_rows` calls `module_key_from_normalized` for every file.
Many files map to the same module string.
We can use a `BTreeMap<String, String>` (or Hash) where key is the `module` string we just computed?
No, we computed it, so we already allocated it.
We want to avoid allocation.

Wait, `module_key_from_normalized` logic:
It takes a `path` (String slice). It splits it.
It constructs a new String `key`.

If we have seen this module key before, we can reuse the `String` (clone it? No, that's still allocation, but `Rc`? No, we need `String` ownership in `FileRow` struct? No, `FileRow` has `module: String`. So we need a `String`. But cloning an existing String is cheaper than building one from parts? Maybe not significantly for short strings.
The main cost is `String::with_capacity` and `push_str`.
Cloning a String is an allocation and a memcpy.
Building a String is an allocation and multiple memcpys.

Wait, if we intern the strings?
If we use `Rc<str>` or `Arc<str>`?
That would require changing `FileRow` struct definition in `tokmd-types`.
That might be a breaking change or larger refactor (Tier 0 crate).
`tokmd-types` is Tier 0.

Let's stick to avoiding repeated computation if possible.
But `module_key_from_normalized` logic depends on `path`.
Path `src/foo/bar.rs` -> module `src/foo`.
Path `src/foo/baz.rs` -> module `src/foo`.

If we memoize `dir_part` -> `module_key`?
`dir_part` is `src/foo`.
So we can have a cache: `Map<&str, String>`.
But we need to own the key in the map?
`Map<String, String>`.
If we have 10,000 files in `src/foo`, we do:
1. Parse path to get `src/foo`.
2. Check cache for `src/foo`.
3. If hit, clone the cached `String` "src/foo".
4. If miss, compute "src/foo", cache it (clone key and value), and return it.

Wait, is cloning a `String` faster than `String::with_capacity` + `push_str`?
Probably slightly, but the main cost is the allocation itself.
If we allocate 10,000 times either way, we haven't saved much.

We want to avoid allocation.
But `FileRow` needs an owned `String`.
Unless we change `FileRow` to use `Cow` or `Rc`.

Let's check `FileRow` in `crates/tokmd-types/src/lib.rs`.
If I can't change `FileRow`, then I must allocate.

Wait! `collect_file_rows` returns `Vec<FileRow>`.
`FileRow` owns the data.

If `FileRow` owns `String`, we must allocate a `String` for each row.
Unless... we can use `Rc<String>`? No, `tokmd-types` is used by serialization (serde).
`Rc` doesn't serialize nicely? It does.
But `FileRow` is public API.

If I cannot avoid allocation because the struct demands `String`, maybe I can reduce the *cost* of generating it?
`module_key_from_normalized` does logic.
If I can skip the logic and just clone a string, that's faster CPU-wise, even if allocation count is same.

But wait! `module` is used in `create_module_report` too.
In `create_module_report`, we aggregate by module.
We collect `FileRow`s first.
Then we group by `row.module`.

If we change `FileRow` to have `module: Rc<str>`, we save memory and allocations.
Is `tokmd-types` used by consumers directly? It's a library.
Changing public struct fields is a breaking change?
Yes, `tokmd-types` is Tier 0.
"State lives on disk... Tier 0: Core data structures, no dependencies."
Changing it is possible but risky for blast radius.

Is there another way?
In `collect_file_rows`, we create `FileRow`.
Maybe we can optimize `collect_file_rows` itself?

Wait, look at `normalize_path`.
It returns `String`.
Then `collect_file_rows` clones it for `Key`.
```rust
            let key = Key {
                path: path.clone(),
                //...
            };
```
And `module` is also derived from `path`.

We have:
1. `path` (String) from `normalize_path`.
2. `module` (String) from `module_key_from_normalized`.
3. `Key` owns `path`.
4. `map` values own `module`.

Eventually `collect_file_rows` returns `Vec<FileRow>`.

If I can avoid `normalize_path` allocating when not needed?
We discussed this. `path` needs to be owned by `Key`. So we need an allocation eventually.
Unless `Key` can hold `&str`?
`Key` is used in `BTreeMap`. The map needs to own its keys.
So `path` must be owned.

So for `path`, we can't easily avoid allocation per unique file.

But for `module`?
Multiple files share the same module.
If we have 100 files in one module, we allocate the same string "src/foo" 100 times.
If `FileRow` holds `Rc<String>` (or `Arc`), we allocate once and refcount 99 times.
That saves 99 allocations!

Can I change `FileRow` in `crates/tokmd-types`?
The instructions say: "Maximize SRP-quality performance improvement... Constrain blast radius... Do not constrain curiosity."
Changing Tier 0 types is high blast radius.
"State lives on disk... Tier 0".
If I change `tokmd-types`, I might break JSON serialization if the field type changes?
`Rc<String>` serializes same as `String`.
But downstream code using `FileRow` might break if they expect `String`.
e.g. `row.module.push_str("foo")` would fail.

If `tokmd` is a library, breaking API is a big deal.
But `FileRow` fields are public?
Let's check `crates/tokmd-types/src/lib.rs`.

If I cannot change types, can I optimize `normalize_path`?
Most paths are already normalized (forward slashes, no prefix).
If `path.to_string_lossy()` borrows, and we don't change it, `into_owned()` allocates.
We can't avoid that if we need a `String`.

What about `module_key` calculation?
It does split/join.
If we have a cache:
`let module = cache.entry(dir).or_insert_with(|| compute(dir)).clone();`
Cloning a String is still an allocation.
But it avoids the *computation* (splitting, iterating).
Is the computation expensive?
Splitting a string by `/` and joining few parts.
Probably not very expensive compared to allocation.

Wait!
`collect_file_rows` puts things into a `BTreeMap`.
The `module` string is stored in the *value* of the map.
`(String, Agg)`.
Then later we iterate the map and create `FileRow`s.

```rust
    map.into_iter()
        .map(|(key, (module, agg))| {
             FileRow {
                 module, // move
                 path: key.path,
                 //...
             }
        })
```

If we change the Map value to store `&str`? No, we need ownership.
`Rc<String>`?
The map is local to the function `collect_file_rows`.
We can use `Rc<String>` inside the map!
But `FileRow` needs `String`.
So at the end, `Rc::try_unwrap(module).unwrap_or_else(|rc| (*rc).clone())`?
If many files map to same module, we have many entries in the map.
Wait.
`Key` includes `path`.
So every file has a unique entry in the map.
So every entry has its own `module` String.

If 100 files share "src/foo", we have 100 map entries, each with "src/foo".
We must produce `Vec<FileRow>` where each row has `module: String`.
So we MUST have 100 allocations of "src/foo".
Unless we change `FileRow`.

So, reducing allocations for *module strings* is impossible without changing `FileRow`.

What about `Key`?
`path` is unique.
`lang` is repeated!
`Key { path, lang, kind }`.
`lang` is a String.
"Rust", "Rust", "Rust"...
If we have 10,000 Rust files, we allocate "Rust" 10,000 times.
`tokei` gives us `LanguageType` enum?
No, `tokei::LanguageType` is an enum, but `lang.name()` returns `&'static str` (usually).
In `collect_file_rows`:
```rust
lang: lang_type.name().to_string(),
```
This allocates "Rust" every time!
We can use `SmolStr` or `Rc<str>` in `Key`?
`Key` is private struct inside `collect_file_rows`?
```rust
    // Deterministic map: key ordering is stable.
    #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
    struct Key {
        path: String,
        lang: String,
        kind: FileKind,
    }
```
Yes! `Key` is defined inside `collect_file_rows`.
I can change `Key` to use `&'static str` for `lang`?
Wait, `lang_type.name()` returns `&str`. Is it static?
`tokei::LanguageType` has a `name()` method.
It returns `Cow<'static, str>` or just `&str`?
It returns `&str`.
In `tokei` (I can't see source, but usually enums return static strings).
However, `tokei` supports custom languages maybe?
The iteration is:
`for (lang_type, lang) in languages.iter()`
`lang_type` is `LanguageType`.
If `LanguageType` yields static strings, we can store `&'static str` in `Key`?
But `FileRow` needs `String`.
At the end:
```rust
                lang: key.lang,
```
If `Key` has `&'static str`, we do `key.lang.to_string()` at the end.
We still allocate N times.

BUT!
Inside the loop, we are constructing `Key` to insert into `BTreeMap`.
We clone `path` and allocate `lang` just to probe the map.
`map.entry(key)`.
If the key exists, we wasted the allocation?
But since `path` is unique (mostly), the key usually *doesn't* exist.
So we need to store it.

Wait, do we need `Key` to own the strings?
`BTreeMap` keys must be owned.

Is there any low-hanging fruit?
`normalize_path`.
It strips `./`.
It replaces `\` with `/`.
It strips prefix.

If we can improve `normalize_path` to avoid allocation when it's already clean?
Currently:
```rust
    if slice.len() == s.len() {
        s.into_owned()
    }
```
`s` is `Cow`. If `s` is Borrowed, `into_owned` allocates.
If we can return `Cow`, we save allocation... BUT `FileRow` needs String.
So we defer allocation.
But we need it for `Key` immediately.
So we save nothing.

Let's look at `create_module_report`.
```rust
    let file_rows = collect_file_rows(languages, module_roots, module_depth, children, None);
```
It calls `collect_file_rows`. This allocates strings for all files.
Then:
```rust
    let mut by_module: BTreeMap<String, Agg> = BTreeMap::new();
    for r in &file_rows {
        let entry = by_module.entry(r.module.clone()).or_default();
        // ...
    }
```
Here! `r.module.clone()`!
We clone the module string for every file to probe the map.
If `by_module` is `BTreeMap<String, Agg>`, we can query it with `&str`?
No, `BTreeMap::entry` takes the key by value!
Use `entry` API requires ownership.
BUT, we can check if it exists first?
`if let Some(agg) = by_module.get_mut(&r.module) { ... } else { ... }`
`get_mut` takes `&Q` where `String: Borrow<Q>`. So `&str` works.
So we can avoid cloning if the key exists!
Only clone if we need to insert.

For a module with 100 files:
Current: 100 clones.
Proposed: 1 clone (insert), 99 lookups (no clone).

This is a **HUGE** win for `create_module_report`!
And `tokmd module` command uses this.

Also `collect_file_rows` creates `FileRow`s.
`create_module_report` iterates them.

So, Option A:
Optimize `create_module_report` to use `get_mut` with `&str` instead of `entry` with `String`.

This is purely in `crates/tokmd-model/src/lib.rs`.
It's safe, SRP, and likely high impact for `tokmd module`.

Let's check if there are other places.
`create_lang_report` uses `LangAgg` struct but does manual iteration.
```rust
            for (lang_type, lang) in languages.iter() {
                // ...
            }
```
It doesn't use a map with string keys (except internally in tokei?).
It iterates `languages` (map).

`collect_file_rows` itself uses `BTreeMap<Key, ...>`.
`Key` has `path` and `lang`.
Since `path` is unique, we almost always insert.
So `entry` is correct there.

But `create_module_report` groups many files into few modules.
So `get_mut` optimization applies perfectly.

Another spot: `collect_file_rows` calls `module_key_from_normalized` which allocates.
Can we avoid that?
Only if we don't need the string. But we store it in `FileRow`.

So, `create_module_report` optimization is the best target.

Let's check `crates/tokmd-model/src/lib.rs` content again to be sure.

```rust
pub fn create_module_report(...) -> ModuleReport {
    // ...
    let file_rows = collect_file_rows(...);

    // ...
    let mut by_module: BTreeMap<String, Agg> = BTreeMap::new();
    for r in &file_rows {
        let entry = by_module.entry(r.module.clone()).or_default();
        entry.code += r.code;
        // ...
    }
```

Yes! `r.module.clone()` is called for every file row.
If we have 10k files and 50 modules, we do 10k clones.
With optimization, we do 50 clones.

This is a classic Rust optimization.

**Plan:**
1. Benchmark `tokmd module` on the repo itself.
2. Apply `get_mut` optimization in `create_module_report`.
3. Verify.

I also see `unique_parent_file_count` iterates and normalizes paths again?
```rust
pub fn unique_parent_file_count(languages: &Languages) -> usize {
    let mut seen: BTreeSet<String> = BTreeSet::new();
    for (_lang_type, lang) in languages.iter() {
        for report in &lang.reports {
            let path = normalize_path(&report.name, None);
            seen.insert(path);
        }
    }
    seen.len()
}
```
This is called in `create_module_report` and `create_lang_report`.
`collect_file_rows` ALSO normalizes paths.
So we are normalizing paths twice (or thrice).
Normalization allocates a String.
For 10k files, that's 20k allocations.

In `create_module_report`:
1. `collect_file_rows` -> normalizes all paths.
2. `unique_parent_file_count` -> normalizes all paths again.
3. `module_files` calculation -> normalizes all paths again!

```rust
    // Unique parent files per module.
    let mut module_files: BTreeMap<String, BTreeSet<String>> = BTreeMap::new();
    for (lang_type, lang) in languages.iter() {
        let _ = lang_type; // keep the pattern explicit; we only need reports
        for report in &lang.reports {
            let path = normalize_path(&report.name, None); // ALLOCATION
            let module = module_key_from_normalized(&path, module_roots, module_depth); // ALLOCATION
            module_files.entry(module).or_default().insert(path);
        }
    }
```

Wait, `file_rows` already contains normalized paths and modules!
Why are we re-calculating `module_files` from `languages`?

`file_rows` contains `FileRow { path, module, kind, ... }`.
`kind` can be `Parent` or `Child`.
`unique_parent_file_count` cares about Parent files.

If `file_rows` has all parent files (it does), we can just iterate `file_rows` to count unique files per module?

```rust
    for r in &file_rows {
        if r.kind == FileKind::Parent {
             // ...
        }
    }
```

If we use `file_rows` to populate `module_files`, we avoid re-normalizing and re-computing module keys.
This saves:
- 10k path normalizations (allocations).
- 10k module key computations (allocations).
- 10k map insertions (or at least lookups).

Wait, `collect_file_rows` returns aggregated rows.
If tokei reports same file multiple times (unlikely for Parent, but possible?), `collect_file_rows` aggregates them.
`collect_file_rows` maps by `(path, lang, kind)`.
So if a file has 1 language, it appears once.
If a file has mixed languages (e.g. HTML + PHP), and tokei reports them as separate parent reports?
No, tokei usually reports one parent language and others as children.
But if it does report multiple parent entries for same file? `collect_file_rows` keeps them separate if `lang` differs.
`Key { path, lang, kind }`.

If we want "Unique parent files", we just want unique `path`.
In `file_rows`, we might have:
`path="foo.html", lang="HTML"`
`path="foo.html", lang="JS"` (if JS is child? No, children are separate kind).
If multiple parent languages claim the same file? (Unlikely).

Let's assume `file_rows` is reliable.
If we iterate `file_rows` and filter for `FileKind::Parent`, we get all parent file contributions.
Since `collect_file_rows` keys by `path` + `lang`, we might have duplicates of `path`.
e.g. `foo.rs` is counted in Rust.
`foo.rs` is counted in... Comments? No, that's inside stats.

So usually 1 file -> 1 parent row.
If so, iterating `file_rows` is much faster.

And `unique_parent_file_count` is also redundant if we can derive it from `file_rows`.
`file_rows` has all files.
`total_files = file_rows.iter().filter(|r| r.kind == FileKind::Parent).map(|r| &r.path).collect::<HashSet>().len()`?

So, I have TWO improvements for `create_module_report`:
1. Use `get_mut` for aggregation map. (Easy, local).
2. Reuse `file_rows` to compute `module_files` and `total_files`, avoiding re-scan.

I should check if `file_rows` contains everything needed.
`collect_file_rows` calls `normalize_path(&report.name, strip_prefix)`.
`create_module_report` calls it with `None` as strip_prefix.
`collect_file_rows` is called with `None` in `create_module_report`.
So paths are identical.

So, I can rewrite `create_module_report` to avoid the second pass over `languages`.

This looks like a solid "Scout" target.
"Reuse repeated parsing/formatting work".

I'll finalize the plan.

**Target:** `create_module_report` in `tokmd-model`.
**Changes:**
1. Optimize `by_module` aggregation using `get_mut`.
2. Optimize `module_files` collection by iterating `file_rows` instead of `languages`.
3. Optimize `total_files` calculation similarly (reuse `module_files` size or `file_rows`).

This removes O(N) allocations and normalizations.

I'll check `tokmd-model/src/lib.rs` imports to ensure I have `HashSet` or `BTreeSet`.
It has `BTreeSet`.

I'll create the proof method now.
I'll write a simple bash script to time `cargo run --release -- module` before and after.

Proof placeholders:
- Baseline time.
- Optimized time.

Let's prepare the run log update.
I'll select "Lane B".
I'll choose "Option A" (Implement the optimizations).
Proof method: `time`.

I'll write the run envelope update.

But first, I need to know if `tokmd` builds and runs.
I'll run `cargo build --release` first (as part of bootstrapping/verifying environment).
And I'll try to run `cargo run --release -- module` to see if it works and what the output looks like.
(It might need a path argument? Defaults to current dir?)
`tokmd module` usually scans current dir.

I'll start building. This might take a while. I'll use background.
Wait, I shouldn't use background if I need to wait for it.
I'll run `cargo build --release` normally.
Then I'll run the "benchmark".

I'll also check `crates/tokmd-types/src/lib.rs` to confirm `FileRow` struct definition, just in case.
And `crates/tokmd-scan/src/lib.rs` was already read.

I'll read `crates/tokmd-types/src/lib.rs`.