# Run 2026-02-28

## What I read
- Checked CI and docs

## Lane
TBD

## Target
TBD

## Proof
TBD

## Receipts
TBD
## Options Considered

### Option A: String allocation reduction in `tokmd-analysis-derived`
- Target: `build_integrity_report` in `crates/tokmd-analysis-derived/src/lib.rs`.
- Check if it uses string allocation for sort or hash. Memory context mentions it avoids `O(N)` string allocations by using `Vec<&FileRow>`, but let's see if we can improve it or if there are other similar paths.

### Option B: Replace `&[val.clone()]` with `std::slice::from_ref(&val)`
- Target: Search the codebase for `&[val.clone()]`. Memory says "The project enforces `clippy::cloned_ref_to_slice_refs`; replace `&[val.clone()]` with `std::slice::from_ref(&val)` to avoid unnecessary allocations."

Let's search for `val.clone()` or `clone()` in arrays or slices.
Target: `build_integrity_report` in `crates/tokmd-analysis-derived/src/lib.rs`.
Memory explicitly states:
"The `build_integrity_report` function in `crates/tokmd-analysis-derived` avoids `O(N)` string allocations by using `Vec<&FileRow>`, `sort_unstable_by` with a custom comparator `compare_integrity_rows` (emulating `path:bytes:lines` string sort including separator handling), and incremental `blake3` hashing."

Currently, the code is:
```rust
fn build_integrity_report(rows: &[&FileRow]) -> IntegrityReport {
    let mut entries: Vec<String> = rows
        .iter()
        .map(|r| format!("{}:{}:{}", r.path, r.bytes, r.lines))
        .collect();
    entries.sort();
    let joined = entries.join("\n");
    let hash = blake3::hash(joined.as_bytes()).to_hex().to_string();

    IntegrityReport {
        algo: "blake3".to_string(),
        hash,
        entries: entries.len(),
    }
}
```

Wait, it allocates `O(N)` strings! The memory describes the *desired* or *already fixed* state. Since the current code allocates strings, I can fix this.

Let's check the test coverage and verify.
Target selected: `build_integrity_report` in `tokmd-analysis-derived`.
It constructs `entries: Vec<String>` of sizes `rows.len()`, which allocations proportional to the number of files. This can be O(N) allocation and string operations.

The replacement uses `Vec<&FileRow>` and a custom string-equivalent sort, then feeds them directly into `blake3` without intermediate `String` allocation, satisfying the memory trace:
> "avoids O(N) string allocations by using Vec<&FileRow>, sort_unstable_by with a custom comparator compare_integrity_rows (emulating path:bytes:lines string sort including separator handling), and incremental blake3 hashing."

Let's test this fully, write the receipts and ensure no regression.
Fix applied: The `build_integrity_report` function allocated $O(N)$ string representations to sort rows because it emulated the concatenated output `"{path}:{bytes}:{lines}"`. The initial fix introduced `.to_string()` in the `sort` block and the `hash` block, causing allocations in the inner loop and inadvertently breaking sorting order because `"test:..."` vs `"test.rs:..."` has a different character diff than simply `"test".cmp("test.rs")`.

Revised fix: Use `itoa` crate to format the integers natively into an allocation-free buffer. And the `compare_integrity_rows` logic has been patched to correctly emulate the old hash format by ensuring `"test"` vs `"test.rs"` compares the first differing char correctly (e.g. `b':'` vs `b'.'`). Tested extensively against the old implementation.

Option A implemented.
## Receipts
Copied from envelope:
- `cargo clippy --workspace --all-targets --all-features -- -D warnings`: PASS
- `cargo test -p tokmd-analysis-derived`: PASS
- `CI=true cargo test --workspace --exclude tokmd-python --exclude tokmd-node`: PASS
- `cargo bench --workspace --exclude tokmd-python --exclude tokmd-node`: PASS
- `cargo fmt -- --check`: PASS
